#include "path_finding.hpp"
#include <assert.h>
#include <functional>
#include <queue>
#include <stack>

auto findKey(const std::string& value,
    const std::map<std::string, std::string>& pages)
{
    for (const auto& page : pages) {
        if (page.second == value) {
            return page.first;
        }
    }
    NoSuchValueException error{value};
    throw error;
}

template <class LIST>
bool pathFinding(const std::string& start_value,
    const std::string& goal_value,
    const std::map<std::string, std::string>& pages,
    const std::map<std::string, std::set<std::string>>& links,
    LIST& list,
    LIST& path,
    const std::function<std::string(LIST&)>& get_first)
{
    std::string start_key;
    std::string goal_key;
    try {
        start_key = findKey(start_value, pages);
        goal_key = findKey(goal_value, pages);
    } catch (NoSuchValueException error) {
        throw error;
    }

    std::map<std::string, bool> is_searched;
    list.push(start_key);
    is_searched[start_key] = true;

    while (!list.empty()) {
        auto v = get_first(list);
        list.pop();
        /*auto links_of_v = links.find(v);
        if (links_of_v != links.end()) {*/
        if (links.count(v)) {
            path.push(v);
            for (auto link : links.at(v)) {
                if (link == goal_key) {
                    is_searched[link] = true;
                    list.push(link);
                    return 1;
                }
                if (!is_searched[link]) {
                    //std::cout << pages.at(link) << std::endl;
                    is_searched[link] = true;
                    list.push(link);
                }
            }
        }
    }
    return 0;
}

template <class LIST>
void showPath(const std::map<std::string, std::string>& pages,
    LIST& list,
    const std::function<std::string(LIST&)>& get_first)
{
    while (!list.empty()) {
        std::cout << pages.at(get_first(list)) << std::endl;
        list.pop();
    }
}

void depthFirstSearch(const std::string& start_value,
    const std::string& goal_value,
    const std::map<std::string, std::string>& pages,
    const std::map<std::string, std::set<std::string>>& links)
{
    auto get_first = [](std::stack<std::string>& list) { return list.top(); };
    std::stack<std::string> list;
    std::stack<std::string> path;

    if (pathFinding<std::stack<std::string>>(start_value, goal_value, pages, links, list, path, get_first)) {
        std::cout << "START!" << std::endl;
        showPath<std::stack<std::string>>(pages, path, get_first);
        std::cout << "GOAL!" << std::endl;
    } else {
        std::cout << "no path " + start_value + " to " + goal_value << std::endl;
    }
}

void breadthFirstSearch(const std::string& start_value,
    const std::string& goal_value,
    const std::map<std::string, std::string>& pages,
    const std::map<std::string, std::set<std::string>>& links)
{
    auto get_first = [](std::queue<std::string>& list) { return list.front(); };
    std::queue<std::string> list;
    std::queue<std::string> path;
    if (pathFinding<std::queue<std::string>>(start_value, goal_value, pages, links, list, path, get_first)) {
        std::cout << "START!" << std::endl;
        showPath<std::queue<std::string>>(pages, path, get_first);
        std::cout << "GOAL!" << std::endl;
    } else {
        std::cout << "no path " + start_value + " to " + goal_value << std::endl;
    }
}
